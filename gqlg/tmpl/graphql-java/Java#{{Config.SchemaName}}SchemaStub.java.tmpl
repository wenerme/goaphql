{{template "JavaPackage" .}}
import com.google.common.reflect.TypeToken;
import graphql.schema.idl.*;
import graphql.schema.*;
import com.google.common.base.Preconditions;

public interface {{Config.SchemaName}}SchemaStub {

    @lombok.extern.slf4j.Slf4j
    public class WiringFactoryStub implements WiringFactory {

    @Override
    public DataFetcher getDefaultDataFetcher(FieldWiringEnvironment environment) {
        String name = environment.getParentType().getName();
        switch (name) {
    {{range .GetDefinitions -}}
    {{if eq (TypeNameOf .) "ObjectTypeDefinition" -}}
        case "{{.Name}}":
            return this::fetch{{.Name}};
    {{- end}}
    {{- end}}
        default:
            log.warn("No fetcher for {}", name);
        }
        return null;
    }


    {{range .GetDefinitions -}}
    {{if eq (TypeNameOf .) "ObjectTypeDefinition" -}}
    {{- $def := . -}}
        public Object fetch{{.Name}}(DataFetchingEnvironment environment) {

            {{GenJavaType .Name}} resolver = environment.getSource();
            ValueResolver valueResolver = null;
            switch (environment.getFieldDefinition().getName()) {
    {{range .FieldDefinitions -}}
    {{- $field := . -}}
                case "{{.Name}}":
                    valueResolver = resolve(resolver::resolve{{ToUpperCamel .Name}}, buildValueResolver(
                        new ValueResolverImpl<{{if .ArgumentDefinitions}}{{GenJavaType $def.Name}}.{{ToUpperCamel .Name}}Argument{{else}}Void{{end}},{{GenJavaType .Type}}>(){},
                        environment
                    ));
                    break;
    {{- end}}
                default:
                    return fetchFallback(environment);
            }
            Preconditions.checkState(valueResolver.isResolved(), "Value not resolved");
            return valueResolver.getFeature();
        }
    {{- end}}
    {{- end}}

        @SneakyThrows
        public <IN, OUT> ValueResolver<IN, OUT> buildValueResolver(
            ValueResolverImpl<IN, OUT> resolver,
            DataFetchingEnvironment environment
        ) {
            IN argument = null;

            if (resolver.getArgumentType().getRawType() != Void.class) {
            argument = (IN) resolver.getArgumentType().getRawType().newInstance();
            BeanCopy.fromMap(environment.getArguments()).toBean(argument).copy();
            }

            resolver
                .setArgument(argument)
                .setTypeName(environment.getFieldDefinition().getType().getName())
                .setFieldName(environment.getFieldDefinition().getName())
            ;

            return resolver;
        }

        protected Object fetchFallback(DataFetchingEnvironment environment) {
            log.warn(
                "Can not fetch {}.{}",
                environment.getParentType().getName(),
                environment.getFieldDefinition().getName());
            throw new AssertionError();
        }

        private <IN, OUT> ValueResolver<IN, OUT> resolve(
            ResolverFunction<IN, OUT> function,
            ValueResolver<IN, OUT> resolver
        ) {
            function.accept(resolver);
            return resolver;
        }

        interface ResolverFunction<IN, OUT> extends Consumer<ValueResolver<IN, OUT>> {

        }
    }
}
